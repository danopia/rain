<!doctype html>

<head>
  <title>Rain</title>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/site.css">

  <script src="main.js"></script>
  <script src="irc-parse.js"></script>
</head>

<body id="body">
    <main id="main"></main>
</body>

<script>
 let node = document.getElementById('main')
 let app = Elm.Main.embed(node)
 let scrollStick = true

 // Ask for permission to show notifications
 if (Notification.permission === 'default') { Notification.requestPermission() }

 window.addEventListener('wheel', () => {
     const padding = window.innerHeight
     if (document.body.scrollTop >= document.body.scrollHeight - padding) {
         scrollStick = true
     } else {
         scrollStick = false
     }
 })

 app.ports.parse_raw.subscribe(args => {
     let [server, line] = args

     if (line.trim() === 'AUTHENTICATE') {
         return app.ports.irc_connected.send(server)
     }

     let p = parse_irc(line.replace(/[\r\n]/g, ''))

     if (p === null) {
         console.error('failed to parse message:', line)
         return
     }

     p.time = p.tags.time ? +new Date(p.tags.time) : Date.now()
     p.prefix = p.prefix || ''

     console.log('parsed_message:', server, p)

     app.ports.irc_messages.send([server, p])
 })

 app.ports.refresh_scroll_position.subscribe(force => {
     // Bail if we're not at the bottom of the page (don't interrupt scrolling)
     if (!force && !scrollStick) {
         return
     }

     // DOM isn't fully rendered when we're called, so wait for it.
     window.requestAnimationFrame(() =>
         document.body.scrollTop = document.body.scrollHeight
     )
 })

 app.ports.send_notification.subscribe(args => {
     let [title, message] = args

     let notif = new Notification(title, {body: message})

     setTimeout(notif.close.bind(notif), 5000)
 })

 // push saved server configuration
 if (window.localStorage.savedServers) {
     let saved = JSON.parse(window.localStorage.savedServers)
     Object.keys(saved).forEach(k => {
         app.ports.saved_servers.send(saved[k])
     })
 }
</script>
